"""
    使用 Dijkstra 算法计算指定点 v0 到图 G 中任意点的最短路径的距离
    INF 为设定的无限远距离值，假设为999
    此方法可以解决双向最短路径问题，但不能解决负权值边的问题
    可以通过多次迭代倒推出最优路径
"""

"""
    初始化图参数，把路线图抽象为邻接表矩阵，把每个点的邻近点(包括自身)填入表中
    字典各个键数字序号映射图中字母，如A->1，B->2，以此类推
    一级字典键代表线段始点，二级字典键代表线段终点，二级字典值代表运输时间
"""
G = {1: {1: 0, 2: 90, 3: 138, 4: 48},
     2: {1: 90, 2: 0, 3: 66, 5: 84},
     3: {1: 138, 2: 66, 3: 0, 4: 156, 6: 90},
     4: {1: 48, 3: 156, 4: 0, 7: 48},
     5: {2: 84, 5: 0, 6: 120, 9: 184},
     6: {3: 90, 5: 120, 6: 0, 7: 132, 8: 60},
     7: {4: 48, 6: 132, 7: 0, 8: 48, 10: 138},
     8: {6: 60, 7: 48, 8: 0, 9: 132, 10: 126},
     9: {5: 184, 8: 132, 9: 0, 10: 126},
     10: {7: 138, 8: 126, 9: 126, 10: 0}}


def Dijkstra(G, v0, vx, INF=999):
    known = set()                   # 创建元组来存放已决点，已决点不进入下次运算
    seq = v0                       # 当前正在运算的点的序号数(seq即为矩阵行数)
    dis = dict((k, INF) for k in G.keys())   # 创建初始路径结果并全设为无穷大
    dis[v0] = 0                    # 起点到起点自身的运输时间肯定为0，咱直接在这改
    last_best = 0                  # 上一最优点初始定为0

    while len(known) < len(G):            # 判定是否所有点都已逐一验证过
        known.add(seq)                # 开始计算新序号的点，咱先把它记入元组再下手
        for w in G[seq]:                # 以当前点的中心向邻近点扩散(w即为矩阵列数)
            if dis[seq] + G[seq][w] < dis[w]: # 若从当前到某点时间小于dis内记载
                dis[w] = dis[seq] + G[seq][w] # 则对dis记载数据更新
                if seq!=vx and w==vx:   # 若当下更新的部分起点非给定终点，终点却是
                    last_best = seq       # 则当下更新的部分就是上一最优点
        new = INF
        for v in dis.keys():                    # 以下更新当前点序号数
            if v in known:
                continue
            if dis[v] < new:
                new = dis[v]
                seq = v
    return dis, last_best

b=10
while b!=1:
    v0 = int(input('请输入起点:'))
    vx = int(input('请输入终点(后几次为上一最优点):'))
    returnx = Dijkstra(G, v0, vx)
    a = returnx[0]
    b = returnx[1]
    print('最短路径为{},终点的上一最优点是{}。'.format(a, b))